import type { Database } from 'better-sqlite3';
import { EOL } from 'os';

export type DynamicQuery06DynamicParams = {
	select?: DynamicQuery06Select;
	where?: DynamicQuery06Where[];
	orderBy: DynamicQuery06OrderBy[];
}

export type DynamicQuery06Result = {
	id?: number;
	value?: number;
	id_2?: number;
	name?: string;
	descr?: string;
}

export type DynamicQuery06Select = {
	id?: boolean;
	value?: boolean;
	id_2?: boolean;
	name?: boolean;
	descr?: boolean;
}

const selectFragments = {
	id: `m1.id`,
	value: `m1.value`,
	id_2: `m2.id`,
	name: `m2.name`,
	descr: `m2.descr`,
} as const;

const NumericOperatorList = ['=', '<>', '>', '<', '>=', '<='] as const;
type NumericOperator = typeof NumericOperatorList[number];
type StringOperator = '=' | '<>' | '>' | '<' | '>=' | '<=' | 'LIKE';
type SetOperator = 'IN' | 'NOT IN';
type BetweenOperator = 'BETWEEN';

export type DynamicQuery06Where =
	| { column: 'id'; op: NumericOperator; value: number | null }
	| { column: 'id'; op: SetOperator; value: number[] }
	| { column: 'id'; op: BetweenOperator; value: [number | null, number | null] }
	| { column: 'value'; op: NumericOperator; value: number | null }
	| { column: 'value'; op: SetOperator; value: number[] }
	| { column: 'value'; op: BetweenOperator; value: [number | null, number | null] }
	| { column: 'id_2'; op: NumericOperator; value: number | null }
	| { column: 'id_2'; op: SetOperator; value: number[] }
	| { column: 'id_2'; op: BetweenOperator; value: [number | null, number | null] }
	| { column: 'name'; op: StringOperator; value: string | null }
	| { column: 'name'; op: SetOperator; value: string[] }
	| { column: 'name'; op: BetweenOperator; value: [string | null, string | null] }
	| { column: 'descr'; op: StringOperator; value: string | null }
	| { column: 'descr'; op: SetOperator; value: string[] }
	| { column: 'descr'; op: BetweenOperator; value: [string | null, string | null] }

export function dynamicQuery06(db: Database, params: DynamicQuery06DynamicParams): DynamicQuery06Result[] {

	const { sql, paramsValues } = buildSql(params);
	return db.prepare(sql)
		.raw(true)
		.all(paramsValues)
		.map(data => mapArrayToDynamicQuery06Result(data, params?.select));
}

function buildSql(params: DynamicQuery06DynamicParams) {
	const orderBy = orderByToObject(params.orderBy);
	const paramsValues: any = [];
	const whereColumns = new Set(params?.where?.map(w => w.column) || []);
	let sql = 'SELECT';
	if (params?.select == null || params.select.id) {
		sql = appendSelect(sql, `m1.id`);
	}
	if (params?.select == null || params.select.value) {
		sql = appendSelect(sql, `m1.value`);
	}
	if (params?.select == null || params.select.id_2) {
		sql = appendSelect(sql, `m2.id`);
	}
	if (params?.select == null || params.select.name) {
		sql = appendSelect(sql, `m2.name`);
	}
	if (params?.select == null || params.select.descr) {
		sql = appendSelect(sql, `m2.descr`);
	}
	sql += EOL + `FROM mytable1 m1`;
	if (params?.select == null
		|| params.select.id_2
		|| params.select.name
		|| params.select.descr
		|| whereColumns.has('id_2')
		|| whereColumns.has('name')
		|| whereColumns.has('descr')
		|| orderBy['m2.id'] != null
		|| orderBy['name'] != null
		|| orderBy['m2.name'] != null
		|| orderBy['descr'] != null
		|| orderBy['m2.descr'] != null) {
		sql += EOL + `INNER JOIN mytable2 m2 on m2.id = m1.id`;
	}
	sql += EOL + `WHERE 1 = 1`;
	params?.where?.forEach(condition => {
		const where = whereCondition(condition, () => '?');
		if (where?.hasValue) {
			sql += EOL + 'AND ' + where.sql;
			paramsValues.push(...where.values);
		}
	});
	sql += EOL + `ORDER BY ${buildOrderBy(params.orderBy)}`;
	return { sql, paramsValues }
}

function mapArrayToDynamicQuery06Result(data: any, select?: DynamicQuery06Select) {
	const result = {} as DynamicQuery06Result;
	let rowIndex = -1;
	if (select == null || select.id) {
		rowIndex++;
		result.id = data[rowIndex];
	}
	if (select == null || select.value) {
		rowIndex++;
		result.value = data[rowIndex];
	}
	if (select == null || select.id_2) {
		rowIndex++;
		result.id_2 = data[rowIndex];
	}
	if (select == null || select.name) {
		rowIndex++;
		result.name = data[rowIndex];
	}
	if (select == null || select.descr) {
		rowIndex++;
		result.descr = data[rowIndex];
	}
	return result;
}

function appendSelect(sql: string, selectField: string) {
	if (sql.toUpperCase().endsWith('SELECT')) {
		return sql + EOL + selectField;
	}
	else {
		return sql + ', ' + EOL + selectField;
	}
}

function orderByToObject(orderBy: DynamicQuery06DynamicParams['orderBy']) {
	const obj = {} as any;
	orderBy?.forEach(order => {
		obj[order[0]] = true;
	});
	return obj;
}

type WhereConditionResult = {
	sql: string;
	hasValue: boolean;
	values: any[];
}

function whereCondition(condition: DynamicQuery06Where, placeholder: () => string): WhereConditionResult | null {
	const selectFragment = selectFragments[condition.column];
	const { op, value } = condition;

	if (op === 'LIKE') {
		return {
			sql: `${selectFragment} LIKE ${placeholder()}`,
			hasValue: value != null,
			values: [value]
		}
	}
	if (op === 'BETWEEN') {
		const [from, to] = Array.isArray(value) ? value : [null, null];
		return {
			sql: `${selectFragment} BETWEEN ${placeholder()} AND ${placeholder()}`,
			hasValue: from != null && to != null,
			values: [from, to]
		}
	}
	if (op === 'IN' || op === 'NOT IN') {
		if (!Array.isArray(value) || value.length === 0) {
			return { sql: '', hasValue: false, values: [] };
		}
		return {
			sql: `${selectFragment} ${op} (${value.map(() => placeholder()).join(', ')})`,
			hasValue: true,
			values: value
		}
	}
	if (NumericOperatorList.includes(op)) {
		return {
			sql: `${selectFragment} ${op} ${placeholder()}`,
			hasValue: value != null,
			values: [value]
		}
	}
	return null;
}

const orderByColumns = ['m1.id', 'value', 'm1.value', 'm2.id', 'name', 'm2.name', 'descr', 'm2.descr'] as const;

export type DynamicQuery06OrderBy = {
	column: typeof orderByColumns[number];
	direction: 'asc' | 'desc';
}

function buildOrderBy(orderBy: DynamicQuery06OrderBy[]): string {
	if (!Array.isArray(orderBy) || orderBy.length === 0) {
		throw new Error('orderBy must be a non-empty array');
	}

	for (const { column, direction } of orderBy) {
		if (!orderByColumns.includes(column)) {
			throw new Error(`Invalid orderBy column: ${column}`);
		}
		if (direction !== 'asc' && direction !== 'desc') {
			throw new Error(`Invalid orderBy direction: ${direction}`);
		}
	}

	return orderBy
		.map(({ column, direction }) => `"${column}" ${direction.toUpperCase()}`)
		.join(', ');
}